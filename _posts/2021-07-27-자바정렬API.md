---
title: "Arrays.sort()와 Collections.sort() 비교"
excerpt: "Java API가 제공하는 정렬 메서드의 시간 복잡도 비교"

categories:
  - Java
tags:
  - [Java, Algorithm]

toc: true
toc_sticky: true

date: 2021-07-27
last_modified_at: 2021-07-27
---

## Arrays.sort()와 Collections.sort()의 차이점

Collections.sort()컬렉션 목록에서 Arrays.sort()작동하고 배열에서 작동합니다. 내부적으로 Collections.sort()전달된 목록을 배열로 변환하고 Arrays.sort()새로 할당된 배열을 호출 합니다.

## Arrays.sort()의 시간 복잡도

Java 8부터 Arrays.sort()두 가지 다른 정렬 알고리즘을 사용합니다. 의 수정퀵소트 듀얼 피벗 Quicksort라는 이름과 수정 병합 정렬팀소트라고 합니다. 둘 다 시간 복잡도가 O(n log n) 입니다 . 여기서 n은 배열의 총 항목 수입니다.

## Arrays.sort()는 사용할 정렬 알고리즘을 어떻게 결정합니까?

기본 데이터 유형의 배열이 전달되면 빠른 정렬이 선택됩니다. 개체인 경우 정렬을 병합합니다. 위의 메서드 서명에서 Quicksort는 기본 데이터 유형이 전달될 때 호출되고 Timsort는 개체에 대해 호출됩니다. 그 이유는 Quicksort가 안정적이지 않고 Merge Sort가 안정적이기 때문입니다. 안정적인 정렬 알고리즘은 동일한 값을 가진 두 항목이 나란히 나타날 경우 정렬 후에도 동일한 순서를 유지함을 의미합니다.

예를 들어, 배열에서 . 서로 옆에 2개의 3이 있습니다. Quicksort와 같은 불안정한 정렬 알고리즘에서 출력은 동일한 값을 가지더라도 3이 이동된 위치일 수 있습니다 . 원시 데이터 유형의 경우 데이터 유형이 동일한 값을 가지므로 차이점을 알아차릴 수 없지만 객체의 경우에는 그럴 가능성이 높습니다.[1, 3a, 3b, 2, 5][1, 2, 3b, 3a, 5]

또 다른 실제 예는 비디오 게임에서 플레이어의 인벤토리에 있는 검 개체 배열입니다. 플레이어는 인벤토리에서 일부 검을 미리 정렬하고 버튼을 클릭하면 나머지 검이 얼마나 강한지에 따라 자동으로 분류됩니다. 플레이어 인벤토리가 에서 로 정렬되었습니다 . 미리 정렬된 항목이 이동되었음을 알 수 있습니다. 병합 정렬과 같은 안정적인 정렬 알고리즘이 사용된 경우 플레이어의 인벤토리는 로 정렬되고 사전 정렬된 항목은 동일한 순서로 정렬됩니다.[sword 510 damage, sword 350 damage, sword 422 damage, sword 150 damage, sword 250 damage][sword 510 damage, sword 422 damage, sword 250 damage, sword 150 damage, sword 350 damage][sword 510 damage, sword 422 damage, sword 350 damage, sword 150 damage, sword 250 damage]

## 비교기가 시간 복잡도를 변경합니까?

아니요, 시간 복잡도는 O(n log n) 으로 유지 됩니다. 비교기는 기본 조건인 a - b오름차순 대신 항목이 비교되는 조건만 변경합니다 .

## 결론

Arrays.sort()배열에서 작동 Collections.sort()하고 목록을 배열로 변환하고 호출 Arrays.sort()합니다. 두 방법 모두 O(n log n) 의 시간 복잡도를 갖습니다. 여기서 n은 배열의 총 항목 수입니다. Arrays.sort()비안정 알고리즘인 Quicksort와 안정적인 알고리즘인 Timsort의 두 가지 구현이 있습니다. 안정적인 정렬 알고리즘은 정렬 후 동일한 값을 가진 항목을 동일한 순서로 유지합니다. Java는 전달된 매개변수를 기반으로 사용할 구현을 결정합니다. 기본 데이터 유형은 안정성이 중요하지 않기 때문에 Quicksort를 사용합니다. 두 개의 동일한 정수의 스왑은 알아차릴 수 없으며 개체의 스왑을 알 수 있기 때문에 Timsort가 개체에 사용됩니다.
