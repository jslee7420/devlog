---
title: "클린코드"
excerpt: ""

categories:
  - ETC
tags:
  - [clean code]

toc: true
toc_sticky: true

date: 2022-03-08
last_modified_at: 2022-03-08
---

나중에 코드를 깨끗하게 다시 작성하는 일은 일어나지 않는다.

Clean code의 필요성
- 나쁜 코드는 시간이 지날 수록 생산성을 떨어뜨림
- 새로운 코드를 짜면서 기존 코드를 읽는다(10:1 = 읽기:쓰기)
- 깨끗한 코드를 위한 다양한 방법/절차/기법을 아는 것이 필요
    - 깨끗한 코드와 나쁜 코드를 구분할 줄 아는 것과 깨끗한 코드를 작성할 줄 아는 것은 다르다.
    - 일단은 깨끗한 코드와 나쁜 코드를 구분하는 것 부터 시작

깨끗한 코드에 대한 절대적 정의는 없음 -> 다른 사람의 의견을 이해/존중하되, 자신만의 생각을 정리 해야함

# 기본 및 이름
1. 의도를 분명히 밝혀라
- 변수/함수/클래스 이름 작성시 고려사항
    - 변수, 함수, 클래스의 존재 이유
    - 수행하는 기능
    - 사용하는 방법
2. 그릇된 정보를 피하라
- accountList -> accountGroup
    - 여러 계정을 그룹으로 묶을 때, 실제 List가 아니라면 XXXList 명명하지 않음
    - List로 선언했더라도 유형을 이름에 넣지 않는 것이 좋음(유형이 변경되는 경우 고려)
- 흡사한 이름 사용하지 않기
    - XYZControllerForEfficientHandlingOfStrings
    - XYZControllerForEfficientStorageOfStrings
- 유사한 개념은 유사한 표기법 사용
- I,O와 같이 오해가 생길 수 있는 변수 이름은 피하기
3. 의미 있게 구분하라
- 연속적인 숫자를 덧붙인 이름(a1, a2, ...aN)은 아무런 정보를 제공하지 못함
- 의미 불분명한 말을 추가한 이름도 아무런 정보를 제공하지 못함.
4. 발음하기 쉬운 이름을 사용하라.
- 프로그래밍은 사회활동이기 때문에 대화/토론에서 발음하기 쉬운이름 사용
5. 검색하기 쉬운 이름을 사용하라
- 이름이 한 문자일 경우 코드에서 눈에 띄지 않음
- 숫자 대신 constant로 정의해서 상수를 사용하는 것이 좋음
- 변수/상수를 코드 여러 곳에서 사용한다면 검색하기 쉬운 이름이 바람직함
6. 인코딩을 피하라
- 변수에 정보를 인코딩하는 것이 필요없어짐
7. 자신의 기억력을 자랑하지 마라
- 한 문자로 된 이름은 좋지 않음
8. 클래스/메소드 이름
- 클래스: 명사나 명사구(동사 X)
    - Good: Customer, WikiPage, Account
    - Bad: Manager, Processor, Data, Info(불용어 사용)
- 메소드: 동사나 동사구가 적합
    - Good: postPayment(), deletePage(), save()
    - Java의 경우 javabean 표준에 따라 값 앞에 접근자(get), 변경자(set), 조건자(is) 붙임
    - 생성자를 중복 정의할 때 정적 팩토리 메소드를 사용(인수를 설명하는 이름을 사용)
9. 한 개념에 한 단어를 사용하라
- 추상적인 개념 하나에 단어 하나를 선택해 이를 고수함
    - 같은 기능을 하는 메소드를 클래스마다 fetch, retrieve등으로 제 각각 부르면 혼란
    - Controller, manager, driver 섞어서 쓰면 혼란
10. 말장난을 하지 마라
- 한 단어를 두 가지 목적으로 사용하지 않아야 함
    - add():기존 값 두개를 더하는 메소드
    - 집합에 값하나를 추가 하는 신규 메소드의 경우, 이름을 add()로 하면 맥락이 다르므로 insert(), append() 이름이 적당함.
11. 해법(Solution) 영역에서 가져온 이름을 사용하라
- 코드를 읽은 사람도 프로그래머라는 사실을 명심
    - 전산 용어, 알고리즘 이름, 패턴 이름등을 사용해도 괜찮음
12. 문제 영역에서 가져온 이름을 사용하라
- 적절한 프로그래머 용어가 없다면 문제 영역에서 이름을 가져옴
    - 문제 영역 개념과 관련이 깊은 코드라면 문제 영역에서 이름을 가져와야 함
13. 의미 있는 맥락을 추가하라
- 메소드가 state 변수 하나만 사용하면, state가 주소의 일부라는 것을 알기 어려움
- 접두어(addr)를 추가하면 더 분명(더 좋은 방법: Address 클래스 생성): addState
14. 불필요한 맥락을 없애라
- 의미가 분명한 경우에는 짧은 이름이 긴 이름보다 좋음

# 함수
1. 작게 만들어라
- 함수를 만드는 가장 규요한 규칙은 '작게!'
 - 함수는 100줄 이하로
- if/else, while문 등에 들어가는 블록은 한 줄 이어야 함
    - 대개 거기서 함수를 호출
    - 중첩 구조가 생길만큼 함수가 커져서는 안됨
        - 각 함수의 들여쓰기 수준은 2단을 넘어서는 안됨
2. 한가지만 해라
- 지정된 함수 이름 아래에서 추상화 수준이 하나면 한 가지 작업만 수행
- 함수 당 추상화 수준은 하나로
- 위에서 아래로 코드 읽기: 내려가기 규칙
3. Switch문
- Switch문은 작고, 한 가지 작업만 하도록 만들기 어렵다.
- 다형성을 이용하여 abstract factory에 숨겨 다형성 객체를 생성하는 코드에서만 사용한다.
4. 함수 인수(단항)
- 이상적인 인수의 개수는 0개
- 함수에 인수를 1개 전달하는 경우
    - 인수에 질문을 던지는 경우
    - 인수를 뭔가로 변환해서 결과를 반환하는 경우
    - 이벤트 함수일 경우(이벤트라는 사실이 코드에 명확하게 드러나야 함)
    - 위 세가지 경우가 아니라면 단항 함수를 피해라
- 플래그 인수
    - bool값을 넘긴하는 것은 함수가 여러 가지 일을 처리한다고 공표하는 것
    - 플래그 인수를 사용하지 말고 대신 함수를 나눠라
- 이항 함수
    - 가능하면 단항으로 바꾸기
- 인수 객체 활용
    - 인수가 2~3개 필요하다면, 객체를 생성하여 인수를 줄인다.
- 동사와 키워드
    - 단항함수는 함수와 인수가 동사/명사 쌍을 이뤄야 함
    ```
    wirte(name);
    ```
    - 함수 이름에 인수 이름을 추가 하면 순서를 기억할 필요가 없음
    ```
    assertExpectEqualsActual(expected, actual);
    ```
5. 부수 효과를 일으키지 마라
- 한 함수에서는 딱 한가지만 수행해야 함
- 출력 인수
6. 명령과 조회를 분리하라
- 한 함수가 둘 다 하면 혼란을 초래함
7. 오류 코드보다 예외를 사용하라
- try/catch를 사용하면 오류 처리 코드가 원래 코드에서 분리되어 깔끔해짐
- try/catch는 정상 동작과 오류 처리 동작이 뒤섞인 구조이므로 별도 함수로 추출
8. 반복하지 마라
- 중복은 악의 근원

# 주석
코드만으로 의도를 표현할 수 있어야 한다.

1. 좋은 주석
- 법적인 주석
- 정보를 제공하는 주석
- 구현 의도를 설명하는 주석
- 의미를 명료하게 밝히는 주석
    - 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히기
- 결과를 경고하는 주석
- TODO 주석
- 중요성을 강조하는 주석
2. 나쁜 주석
- 주절 거리는 주석
- 코드랑 내용이 중복되는 주석, 오해할 여지가 있는 주석
- 의무적으로 다는 주석
- 있으나 마나 한 주석
- 닫는 괄호에 다는 주석
- 이력을 기록하는 주석, 저자를 표시하는 주석
    - 코드의 History 정보를 형상 관리 시스템에서 제공하는 기능 활용
- 함수나 변수로 표현할 수 있는 주석
- 전역 정보를 제공하는 주석
    - 주석을 달아야 한다면 근처에 있는 코드만 기술
- 주석으로 처리한 코드
    - 형상 관리 시스템을 이용하면 이전코드를 잃어버릴 염려는 없음
- 위치를 표시하는 주석
- 모호한 주석

## 형식 맞추기
- 코드는 의사 소통의 일환
- 처음 잡은 구현 스타일과 가독성 수준은 앞으로 바뀔 코드의 품질에 지대한 영향을 미침
- 코드 형식을 자동으로 맞춰주는 도구를 활용 권장
- => 팀은 한가지 규칙에 합의하고 모든 팀원은 규칙을 따라 일관적인 스타일을 유지!

1. 세로 형식 맞추기
- 적절한 행의 길이를 유지
    - 일반적으로 큰 파일보다 작은 파일이 가독성이 좋음
- High Level -> Low Level 순서로 작성
    - 이름은 간단하면서 설명 가능하게
    - 첫부분은 고차원 개념, 알고리즘 설명
    - 아래로 내려가며 의도를 세세하게 묘사
    - 마지막은 저차원 함수와 세부 내역
- 개념은 빈 행으로 분리
    - 각 행은 수식이나 절을 나타내고, 일련의 행 묶음은 완결된 생각 하나를 표현
- 서로 밀접한 행은 세로로 가까이 놓기
    - 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현
    - 비슷한 동작을 하는 함수는 가까이 배치
    - 변수는 사용하는 위치에 최대한 가까이 선언
        - 함수의 첫부분에서 지역변수 선언
        - 루프 제어 변수는 루프문 내부 선언
        - 단 인스턴스 변수는 클래스 맨 처음에 선언
    - 호출 관계가 있는 두 함수는 세로로 가까이 배치
        - 호출 순서대로 함수 정의
2. 가로 형식 맞추기
- 가로 공백과 밀집도
- 적절한 가로 길이를 유지 하라
    - 오른쪽으로 스크롤 x(80~120 정도)
- 가로 정렬은 코드의 진짜 의도가 가려지게 할 수 있음
- 들여쓰기를 통하여 코드가 속하는 범위를 시각적으로 쉽게 파악 가능
- 간단한 if/while문, 짧은 함수에서도 들여쓰기 사용
- 빈 while/for문에는 세미콜론(;)을 새행에다 제대로 들여써서 넣어준다.


## 오류 처리

1. 에러 코드보다 예외를 사용하라
2. Try-Catch-Finally문부터 작성하라
    - Step1. Exception을 던지는지 알아보는 단위 테스트 작성
    - Step2. 단위 테스트에 맞춰 코드 구현 -> Exception이 발생하지 않음으로 테스트 실패
    - Step3. 단위 테스트를 통과하는 코드 구현(잘못된 파일 접근을 시도하도록 구현)
    - Step4. 테스트 성공 후 리팩터링(catch 블록의 예외 유형을 좁힘)
    - Step5. 나머지 논리/로직 추가
    - 권장 구현 방법
        - 먼저 강제로 예외를 일으키는 테스트 케이스 작성
        - 테스트를 통과하게 코드를 작성
3. Exception에 의미를 제공하라
- Exception을 던질 때는 전후 상황을 충분히 포함하도록 함
    - 실패한 코드의 의도를 파악하려면 Exception의 호출 스택만으로 부족
- 오류 메세지에 정보를 담에 Exception과 함께 던짐
    - 오류가 발생한 연산 이름, 오류 유형
4. 호출자를 고려해 Exception 클래스를 정의하라
- 오류를 분류하는 방법은 많음
- But, 오류를 잡아내는 방법이 더 중요
5. 정상 흐름을 정의하라
- 비즈니스 논리와 오류 처리를 잘 분리하면 코드가 깨끗해지지만 오류 감지가 프로그램 언저리로 밀려남
6. null을 반환하지 마라
- 오류를 유발하는 행위
7. null을 전달하지 마라

## 경계
시스템에 들어가는 모든 소프트웨어를 직접 개발하는 경우느 ㄴ들묾
우리코드와 외부 코드의 경계를 깔끔하게 통합해야함

1. 외부 코드 사용하기
- 패키지/ 프레임워크의 인터페이스 제공자와 사용자 사이에 입장차 존재
    - 제공자: 더 많은 환경에서 돌아가도록 적용성을 최대로
    - 사용자: 자신의 요구에 집중하는 인터페이스를 바람
- 경계 인터페이스를 여기저기 넘기지 말라
2. 경계를 살피고 익히기
- 외부 패키지/라이브러리를 테스트 하자
3. 아직 존재하지 않는 코드를 사용하기
- 현재 알지 못하는 코드를 사용해야 한다면 자체 인터페이스를 정의 하여 활용
4. 깨끗한 경계
- 경계에서는 많은 변경이 발생
- 경계에 위치하는 코드를 깔끔히 분리해야함
- 깨끗한 경계를 위한 제안 사항
    - 기대치를 정의하는 테스트케이스 작성
    - 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리
    - 패키지가 제공하는 인터페이스를 우리가 원하는 인터페이스로 변환하여 사용
        - 새로운 클래스로 경계를 감싸거나 Adapter 패턴을 사용


## 클래스
가능한 비공개 상태를 유지할 방법을 강구해야함
클래스는 작게
응집도는 크게
변경하기 쉬운 클래스
- 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춰야 함
- 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리해야함

### 클래스 체계
- 클래스를 정의하는 표준 자바 관례에 따르면, 아래 순서대로 정의
1. static public 상수
2. static private 변수
3. private instance 변수
4. public 함수
5. private 함수는 자신으로 호출하는 public 함수 바로 다음 위치

- 캡슐화를 풀어주는 결정은 최후의 수단

1. 클래스는 작아야 한다.
- 클래스 크기는 '맡은 책임'으로 정의
- 클래스는 단 한의 책임만 가져야 한다.
- 클래스 인스턴스 변수 수는 적게, 각 메서드는 인스턴스 변수를 하나이상 사용
- 클래스가 응집력을 잃으면 쪼개라
2. 변경하기 쉬운 클래스
- 이상적인 시스템은 신규 기능 추가 시, 기존 코드 변경 없이 시스템만 확장
- 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리해야 함
